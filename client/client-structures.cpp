///////////////////////////////////////////////////////////////////////////////
/// @file   baseAI.cpp
///
/// @author Ben
///
/// @brief  Client class implementations
///////////////////////////////////////////////////////////////////////////////


#include "client-structures.h"
#include <cmath>
#include <algorithm>

using std::max;


///////////////////////////////////////////////////////////////////////////////
/// @brief Default Constructor
/////////////////////////////////////////////////////////////////////////////// 
coordinate::coordinate()
{
    x=0;
    y=0;   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Nondefault constructor
///
/// @param X the x position of the coordinate
/// @param Y the y position of the coordinate
/////////////////////////////////////////////////////////////////////////////// 
coordinate::coordinate(const int& X, const int& Y)
{
    x = X;
    y = Y;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Copy constructor
///
/// @param right The coordinate to copy from
/////////////////////////////////////////////////////////////////////////////// 
coordinate::coordinate(const coordinate& right)
{
    *this = right;   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Assignment Operator
///
/// @param right the coordinate to copy from
///
/// @return A reference to the newly assigned coordinate
/////////////////////////////////////////////////////////////////////////////// 
coordinate& coordinate::operator=(const coordinate& right)
{
    this->x = right.x;
    this->y = right.y;   
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Equality Operator
///
/// @param right the coordinate to compare with
///
/// @return True if x==x and y==y, false otherwise
/////////////////////////////////////////////////////////////////////////////// 
bool coordinate::operator==(const coordinate& right)
{
    return (x == right.x && y == right.y);   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Addition operator. Performs coordinate addition
///
/// @param right The coordinate to add
///
/// @return The result of the addition
/////////////////////////////////////////////////////////////////////////////// 
coordinate coordinate::operator+(const coordinate& right) const
{
   coordinate temp(*this);

   temp.x += right.x;
   temp.y += right.y;
      
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Subtraction operator. Performs coordinate subtraction
///
/// @param right The coordinate to subtract
///
/// @return The result of the subtraction
/////////////////////////////////////////////////////////////////////////////// 
coordinate coordinate::operator-(const coordinate& right) const
{
   coordinate temp(*this);

   temp.x -= right.x;
   temp.y -= right.y;
      
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Negation operator. Negates the coordinate
///
/// @param right The coordinate to negate
///
/// @return The result of the negation
/////////////////////////////////////////////////////////////////////////////// 
coordinate coordinate::operator-() const
{
   coordinate temp(*this);

   temp.x = -temp.x;
   temp.y = -temp.y;
      
   return temp;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Computes the manhattan distance from the calling object to calcTo
///
/// @param calcTo the coordinate to calculate the distance to
///
/// @return Distance to that point
/////////////////////////////////////////////////////////////////////////////// 
unsigned int coordinate::distanceTo(const coordinate& calcTo) const
{
    if(max(abs(x-calcTo.x),abs(y-calcTo.y)) == 1)
    {
        return 1;
    }
    return (abs(x-calcTo.x)+abs(y-calcTo.y));
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Default Constructor
/////////////////////////////////////////////////////////////////////////////// 
resource::resource()
{
    remaining = 0;
    location = coordinate(0,0);
    myMultiplier = 0;
    enemyMultiplier = 0;
}

resource::resource(const unsigned long& Remaining, const coordinate& Location, const float& MyMultiplier, const float& EnemyMultiplier)
{
    remaining = Remaining;
    location = Location;
    myMultiplier = MyMultiplier;
    enemyMultiplier = EnemyMultiplier;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Copy Constructor
///
/// @param right the resource to copy from
/////////////////////////////////////////////////////////////////////////////// 
resource::resource(const resource& right)
{
    *this = right;   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Assignment Operator
///
/// @param right the resource to copy from
///
/// @return a reference to the freshly assigned resource
/////////////////////////////////////////////////////////////////////////////// 
resource& resource::operator=(const resource& right)
{
    this->remaining = right.remaining;
    this->location = right.location;
    this->myMultiplier = right.myMultiplier;
    this->enemyMultiplier = right.enemyMultiplier;
    return *this;   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief location accessor
///
/// @return The location of the resource
/////////////////////////////////////////////////////////////////////////////// 
coordinate resource::getLocation() const
{
    return location;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Remaining resource accessor
///
/// @return The amount of resources remaining at the node
/////////////////////////////////////////////////////////////////////////////// 
long resource::getRemaining() const
{
    return remaining;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief multiplier accessor
///
/// @param team The team whose multiplier you desire (true = me, false = enemy)
///
/// @return The multiplier for the team specified
/////////////////////////////////////////////////////////////////////////////// 
float resource::getMultiplier(bool team) const
{
    if(team == me)
    {
        return myMultiplier;
    }
    else
    {
        return enemyMultiplier;
    }
}


///////////////////////////////////////////////////////////////////////////////
/// @brief multiplier mutator
///
/// @param owner The team whose multiplier you want to change
/// @param newMult the new multiplier
/////////////////////////////////////////////////////////////////////////////// 
void resource::setMultiplier(const float& newMult, bool owner)
{
    if(owner == me)
    {
        myMultiplier = newMult;   
    }
    else
    {
        enemyMultiplier = newMult;   
    }
}


///////////////////////////////////////////////////////////////////////////////
/// @brief location mutator
///
/// @param newLoc The new location for the resource node
/////////////////////////////////////////////////////////////////////////////// 
void resource::setLocation(const coordinate& newLoc)
{
    location = newLoc;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief remaining resource mutator
///
/// @param newRemaining The new amount of resources remaining
/////////////////////////////////////////////////////////////////////////////// 
void resource::setRemaining(const long& newRemaining)
{
    remaining = newRemaining;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Default constructor
/////////////////////////////////////////////////////////////////////////////// 
base::base()
{
    location = coordinate(0,0);
    owner = me;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Nondefault constructor
///
/// @param Owner the owner of the base
/// @param Location the location of the base
/////////////////////////////////////////////////////////////////////////////// 
base::base(const bool& Owner, const coordinate& Location)
{
    owner = Owner;
    location = Location;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief Copy constructor
///
/// @param right the base to copy from
/////////////////////////////////////////////////////////////////////////////// 
base::base(const base& right)
{
    *this = right;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Assignment operator
///
/// @param right The base to copy from
///
/// @return A reference to the newly assigned base
/////////////////////////////////////////////////////////////////////////////// 
base& base::operator=(const base& right)
{
    this->owner = right.owner;
    this->location = right.location;
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief owner accessor
///
/// @return The owner of the base (true = me, false = enemy)
/////////////////////////////////////////////////////////////////////////////// 
bool base::getOwner() const
{
    return owner;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief location accessor
///
/// @return The location of the base
/////////////////////////////////////////////////////////////////////////////// 
coordinate base::getLocation() const
{
    return location;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief owner mutator
///
/// @param newOwner the new owner of the base
/////////////////////////////////////////////////////////////////////////////// 
void base::setOwner(const bool& newOwner)
{
    owner = newOwner;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief location mutator
///
/// @param newLoc the new location of the base
/////////////////////////////////////////////////////////////////////////////// 
void base::setLocation(const coordinate& newLoc)
{
    location = newLoc;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Default constructor
/////////////////////////////////////////////////////////////////////////////// 
unitInfo::unitInfo()
{
    unitType = -1;
    name = "NULL";
    cost = 0;
    maxHealth = 0;
    attackPower = 0;
    speed = 0;
    attackRange = 0;  
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Nondefault Constructor
///
/// @param UnitType The type of the unit
/// @param Name the name of the unit
/// @param Cost the cost of the unit
/// @param MaxHealth The maximum health of the unit
/// @param AttackPower The attack power of the unit
/// @param Speed How many moves can be made in one turn
/// @param AttackRange The range of attack for the unit
/////////////////////////////////////////////////////////////////////////////// 
unitInfo::unitInfo(int UnitType, string Name, unsigned long Cost, unsigned long MaxHealth, int AttackPower, int Speed, int AttackRange)
{
    unitType = UnitType;
    name = Name;
    cost = Cost;
    maxHealth = MaxHealth;
    attackPower = AttackPower;
    speed = Speed;
    attackRange = AttackRange;   
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Copy Constructor
///
/// @param right The unitInfo to copy from
/////////////////////////////////////////////////////////////////////////////// 
unitInfo::unitInfo(const unitInfo& right)
{
    *this = right;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Assignment operator
///
/// @param right The unitInfo to copy from
///
/// @return A reference to the newly assigned unitInfo
/////////////////////////////////////////////////////////////////////////////// 
unitInfo& unitInfo::operator=(const unitInfo& right)
{
    this->unitType = right.unitType;
    this->name = right.name;
    this->cost = right.cost;
    this->maxHealth = right.maxHealth;
    this->attackPower = right.attackPower;
    this->speed = right.speed;
    this->attackRange = right.attackRange;  
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief Equivalence operator
///
/// @param right The unitInfo to compare to
///
/// @return True if the unit types match
/////////////////////////////////////////////////////////////////////////////// 
bool unitInfo::operator==(const unitInfo& right)
{
    return(unitType == right.unitType && name == right.name);
}


///////////////////////////////////////////////////////////////////////////////
/// @brief UnitType accessor
///
/// @return The unitType
/////////////////////////////////////////////////////////////////////////////// 
int unitInfo::getUnitType() const
{
    return unitType;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief max health accessor
///
/// @return the maximum health of the unit type
/////////////////////////////////////////////////////////////////////////////// 
unsigned long unitInfo::getMaxHealth() const
{
    return maxHealth;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief attack power accessor
///
/// @return the attack power of the unit type
/////////////////////////////////////////////////////////////////////////////// 
int unitInfo::getAttackPower() const
{
    return attackPower;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief speed accessor
///
/// @return The speed of the unit type
/////////////////////////////////////////////////////////////////////////////// 
int unitInfo::getSpeed() const
{
    return speed;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief attack range accessor
///
/// @return the attack range of the unit type
/////////////////////////////////////////////////////////////////////////////// 
int unitInfo::getAttackRange() const
{
    return attackRange;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief unit cost accessor
///
/// @return the cost of the unit type
/////////////////////////////////////////////////////////////////////////////// 
unsigned long unitInfo::getCost() const
{
    return cost;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief name accessor
///
/// @return The name of the unit type
/////////////////////////////////////////////////////////////////////////////// 
string unitInfo::getName() const
{
    return name;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief unitType mutator
///
/// @param newType The new unit type
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setUnitType(const int& newType)
{
    unitType = newType;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief max health mutator
///
/// @param newMax The new max health
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setMaxHealth(const unsigned long& newMax)
{
    maxHealth = newMax;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief attack power mutator
///
/// @param newPower The new attack power
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setAttackPower(const int& newPower)
{
    attackPower = newPower;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief speed mutator
///
/// @param newSpeed The new speed
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setSpeed(const int& newSpeed)
{
    speed = newSpeed;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief range mutator
///
/// @param newRange the new range
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setAttackRange(const int& newRange)
{
    attackRange = newRange;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief cost mutator
///
/// @param The new cost
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setCost(const unsigned long& newCost)
{
    cost = newCost;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief name mutator
///
/// @param The new unit name
/////////////////////////////////////////////////////////////////////////////// 
void unitInfo::setName(const string& newName)
{
    name = newName;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Default constructor
///////////////////////////////////////////////////////////////////////////////     
unit::unit()
{
    unitID = -1;
    curHealth = 0;
    moves = 0;
    location = coordinate(0,0);
    constants = NULL;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Copy constructor
///
/// @param right the unit to copy from
/////////////////////////////////////////////////////////////////////////////// 
unit::unit(const unit& right)
{
    *this = right;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Nondefault constructor
///
/// @param UnitID The ID of the unit
/// @param CurHealth The current health of the unit
/// @param Location The location of the unit
/// @param Constants The unitInfo for the unit
/////////////////////////////////////////////////////////////////////////////// 
unit::unit(int UnitID, unsigned long CurHealth, const coordinate& Location, unitInfo* Constants)
{
    this->unitID = UnitID;
    this->curHealth = CurHealth;
    this->location = Location;
    this->constants = Constants;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief Assignment operator
///
/// @param right The unit to copy from
///
/// @return A reference to the freshly assigned unit
/////////////////////////////////////////////////////////////////////////////// 
unit& unit::operator=(const unit& right)
{
    this->unitID = right.unitID;
    this->curHealth = right.curHealth;
    this->location = right.location;
    this->moves = right.moves;
    this->constants = right.constants;
    return *this;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Equivalence Operator
///
/// @param right the unit to compare to
///
/// @return True if the unit ID's are equal
/////////////////////////////////////////////////////////////////////////////// 
bool unit::operator==(const unit& right)
{
    return(unitID == right.unitID);
}


///////////////////////////////////////////////////////////////////////////////
/// @brief ID accessor
///
/// @return the unitID
/////////////////////////////////////////////////////////////////////////////// 
int unit::getID() const
{
    return unitID;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief health accessor
///
/// @return the unit's current health
/////////////////////////////////////////////////////////////////////////////// 
long unit::getHealth() const
{
    return curHealth;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief location accessor
///
/// @return The location of the unit
/////////////////////////////////////////////////////////////////////////////// 
coordinate unit::getLocation() const
{
    return location;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief ID mutator
///
/// @param newID the new ID for the unit
/////////////////////////////////////////////////////////////////////////////// 
void unit::setID(const int& newID)
{
    unitID = newID;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Health mutator
///
/// @param newHealth the new health of the unit
/////////////////////////////////////////////////////////////////////////////// 
void unit::setHealth(const long& newHealth)
{
    curHealth = newHealth;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Location mutator
///
/// @param newLoc the new location of the unit
/////////////////////////////////////////////////////////////////////////////// 
void unit::setLocation(const coordinate& newLoc)
{
    location = newLoc;
}

///////////////////////////////////////////////////////////////////////////////
/// @brief Computes the manhattan distance from the calling object to calcTo
///
/// @param calcTo the coordinate to calculate the distance to
///
/// @return Distance to that point
/////////////////////////////////////////////////////////////////////////////// 
unsigned int unit::distanceTo(const coordinate& calcTo) const
{
    return calcTo.distanceTo(getLocation());
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Returns the number of moves remaining for the unit
///
/// @return Number of moves remaining for the unit
/////////////////////////////////////////////////////////////////////////////// 
int unit::getMoves() const
{
    return moves;
}


///////////////////////////////////////////////////////////////////////////////
/// @brief Sets the number of remaining moves for the unit
///
/// @param newMoves the number of moves remaining
/////////////////////////////////////////////////////////////////////////////// 
void unit::setMoves(int newMoves)
{
    moves = newMoves;
}




